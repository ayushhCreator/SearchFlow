# Step 4: CI/CD Basics with GitHub Actions

**Objective:** Set up Continuous Integration/Continuous Deployment (CI/CD) pipeline to automate testing and deployment.

This step will guide you through GitHub Actions, creating workflows, automating tests, and setting up deployment automation.

---

## üéØ What You Will Learn

- What CI/CD is and why it matters
- GitHub Actions workflow structure
- Automatic testing on every commit
- Linting and code quality checks
- Building Docker images automatically
- Deploying to production
- Monitoring workflow execution
- Best practices for CI/CD pipelines

---

## üîÑ Background: Understanding CI/CD

### Without CI/CD

```
Developer writes code
    ‚Üì
Manually tests locally
    ‚Üì
Manually runs linter
    ‚Üì
Manually builds Docker image
    ‚Üì
Manually deploys to server
    ‚Üì
Pray nothing breaks üò∞
```

**Time: Hours, Error Rate: High**

### With CI/CD

```
Developer pushes code
    ‚Üì (Automatic)
Tests run on GitHub
    ‚Üì (Automatic)
Lint checks run
    ‚Üì (Automatic)
Docker image builds
    ‚Üì (Automatic)
Image pushed to registry
    ‚Üì (Automatic)
Deployed to server
    ‚Üì (Automatic)
Health checks verify ‚úÖ
```

**Time: Minutes, Error Rate: Low**

---

## üéì CI/CD Concepts

| Term         | Meaning                               | Example                      |
| ------------ | ------------------------------------- | ---------------------------- |
| **CI**       | Code changes are tested automatically | Running pytest on every push |
| **CD**       | Tested code is deployed automatically | Pushing to production        |
| **Workflow** | Automated sequence of jobs            | Test ‚Üí Build ‚Üí Deploy        |
| **Job**      | Single task in workflow               | "Run tests"                  |
| **Step**     | Individual command in job             | `pip install`                |
| **Event**    | What triggers the workflow            | Push, pull request, schedule |
| **Runner**   | Machine that runs the workflow        | GitHub's servers or your own |

---

## üõ†Ô∏è Step-by-Step Setup

### Step 4.1: Create GitHub Repository

If you haven't already:

```bash
# Initialize git (if not done)
git init

# Add GitHub remote
git remote add origin https://github.com/your-username/searchflow.git

# Create first commit
git add .
git commit -m "Initial commit: Project structure setup"

# Push to GitHub
git branch -M main
git push -u origin main
```

---

### Step 4.2: Create GitHub Actions Directory

```bash
# Create workflows directory
mkdir -p .github/workflows

# Create CI workflow file
touch .github/workflows/ci.yml

# Create deployment workflow file
touch .github/workflows/deploy.yml
```

---

### Step 4.3: Create CI Workflow

Create `.github/workflows/ci.yml`:

```yaml
name: CI Pipeline

# When to run this workflow
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

# Environment variables
env:
  PYTHON_VERSION: "3.12"

jobs:
  # Job 1: Linting and Code Quality
  lint:
    runs-on: ubuntu-latest
    name: Lint and Code Quality

    steps:
      # Checkout code
      - uses: actions/checkout@v4

      # Setup Python
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Cache pip dependencies
      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install black ruff mypy

      # Run Black (code formatting check)
      - name: Check code formatting with Black
        run: black --check app/ tests/
        continue-on-error: true

      # Run Ruff (linting)
      - name: Lint with Ruff
        run: ruff check app/ tests/

      # Run MyPy (type checking)
      - name: Type check with MyPy
        run: mypy app/ --ignore-missing-imports
        continue-on-error: true

  # Job 2: Unit Tests
  test:
    runs-on: ubuntu-latest
    name: Unit Tests

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Run pytest
      - name: Run tests
        run: pytest tests/ -v --cov=app --cov-report=xml

      # Upload coverage reports
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

  # Job 3: Build Docker Image
  build:
    runs-on: ubuntu-latest
    name: Build Docker Image
    needs: [lint, test] # Only run after lint and test pass

    steps:
      - uses: actions/checkout@v4

      # Setup Docker Buildx (for better caching)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Build image (don't push yet)
      - name: Build Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./docker/Dockerfile.api
          push: false
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 4: Integration Tests
  integration-tests:
    runs-on: ubuntu-latest
    name: Integration Tests
    needs: [build]

    services:
      searxng:
        image: searxng/searxng:latest
        options: >-
          --health-cmd "curl -f http://localhost:8888/"
          --health-interval 30s
          --health-timeout 10s
          --health-retries 3

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run integration tests
        run: pytest tests/test_e2e.py -v
        env:
          SEARXNG_URL: http://localhost:8888

# Summary status check
status:
  runs-on: ubuntu-latest
  name: CI Status
  needs: [lint, test, build, integration-tests]
  if: always()

  steps:
    - name: Check CI status
      run: |
        if [ "${{ needs.lint.result }}" = "failure" ] ||
           [ "${{ needs.test.result }}" = "failure" ] ||
           [ "${{ needs.build.result }}" = "failure" ]; then
          echo "CI Pipeline failed"
          exit 1
        fi
        echo "CI Pipeline passed ‚úÖ"
```

**What this workflow does:**

1. **Triggers on:** Push to main/develop or pull requests
2. **Lint Job:** Checks code quality and formatting
3. **Test Job:** Runs unit tests and generates coverage
4. **Build Job:** Builds Docker image (runs only if lint/test pass)
5. **Integration Job:** Tests with actual SearXNG service
6. **Status Job:** Reports overall status

---

### Step 4.4: Create Deployment Workflow

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy to Production

# Only run on tags and main branch
on:
  push:
    branches: [main]
    tags:
      - "v*"
  workflow_dispatch: # Manual trigger

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      # Log in to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels)
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=ref,event=branch
            type=sha

      # Build and push image
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./docker/Dockerfile.api
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Deploy to server (example - customize as needed)
      - name: Deploy to server
        run: |
          echo "Deploying version ${{ github.ref }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          # Add your deployment commands here
          # Example: SSH to server and pull new image

      # Send notification (optional)
      - name: Notify deployment
        if: success()
        run: echo "‚úÖ Deployment successful for ${{ github.ref }}"

      - name: Notify failure
        if: failure()
        run: echo "‚ùå Deployment failed"
```

**What this workflow does:**

1. **Triggers on:** Push to main or manual trigger
2. **Builds image** with semantic versioning
3. **Pushes to registry** (GitHub Container Registry)
4. **Deploys to server** (customize with your hosting)
5. **Sends notifications**

---

### Step 4.5: Create Test Configuration

Create `pytest.ini` for test discovery:

```ini
[pytest]
asyncio_mode = auto
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --strict-markers
markers =
    unit: Unit tests
    integration: Integration tests
    slow: Slow tests
```

---

### Step 4.6: Update Test Files

Update `tests/test_health.py`:

```python
"""
Health Check Tests

Tests for API health endpoints.
"""

import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

@pytest.mark.unit
class TestHealthEndpoints:
    """Tests for health check endpoints"""

    def test_root_endpoint(self):
        """Test root endpoint returns success"""
        response = client.get("/")
        assert response.status_code == 200
        data = response.json()
        assert "message" in data
        assert data["message"] == "SearchFlow is running"

    def test_health_endpoint(self):
        """Test health endpoint returns healthy status"""
        response = client.get("/health")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "healthy"
        assert data["version"] == "0.1.0"
        assert data["service"] == "SearchFlow API"

    def test_health_endpoint_structure(self):
        """Test health endpoint returns all required fields"""
        response = client.get("/health")
        assert response.status_code == 200
        data = response.json()
        required_fields = ["status", "version", "service"]
        for field in required_fields:
            assert field in data

@pytest.mark.unit
def test_api_docs():
    """Test API documentation is available"""
    response = client.get("/docs")
    assert response.status_code == 200
    assert "swagger" in response.text.lower()
```

---

### Step 4.7: Push and Monitor Workflow

**Commit and push:**

```bash
# Add workflows
git add .github/workflows/

# Add test config
git add pytest.ini

# Commit
git commit -m "Add CI/CD workflows"

# Push to trigger workflows
git push origin main
```

**Monitor workflow execution:**

1. Go to your GitHub repository
2. Click on "Actions" tab
3. See workflows running in real-time
4. Click on workflow to see detailed logs

---

### Step 4.8: View Workflow Logs

**In GitHub UI:**

1. Actions tab ‚Üí CI Pipeline
2. Click on the latest run
3. See all jobs and steps
4. Click on failed step to see error

**In terminal:**

```bash
# Install GitHub CLI
curl https://cli.github.com/install.sh | sh

# View workflow status
gh run list

# View specific workflow
gh run view <run-id>

# View workflow logs
gh run view <run-id> --log
```

---

### Step 4.9: Add Status Badge to README

Add this to your `README.md`:

```markdown
# SearchFlow

![CI Pipeline](https://github.com/your-username/searchflow/workflows/CI%20Pipeline/badge.svg)
![Deploy](https://github.com/your-username/searchflow/workflows/Deploy%20to%20Production/badge.svg)

...rest of README...
```

This shows workflow status directly in README.

---

## üìã Workflow Triggers

| Trigger             | When                 | Use Case             |
| ------------------- | -------------------- | -------------------- |
| `push`              | When code is pushed  | Every commit         |
| `pull_request`      | When PR is created   | Code review          |
| `schedule`          | On schedule (cron)   | Nightly builds       |
| `workflow_dispatch` | Manual trigger       | On-demand            |
| `release`           | When release created | Deploy to production |

**Example scheduled workflow:**

```yaml
on:
  schedule:
    - cron: "0 2 * * *" # Daily at 2 AM UTC
```

---

## üîê GitHub Secrets

Secrets are encrypted environment variables for sensitive data.

**Set a secret:**

1. Go to GitHub repository
2. Settings ‚Üí Secrets and variables ‚Üí Actions
3. Click "New repository secret"
4. Add name and value
5. Use in workflow: `${{ secrets.SECRET_NAME }}`

**Common secrets:**

```yaml
secrets:
  DOCKER_HUB_USERNAME: your_username
  DOCKER_HUB_TOKEN: your_token
  DEPLOY_SSH_KEY: your_private_key
  API_TOKEN: your_api_token
```

---

## üß™ Running Tests Locally

**Run all tests:**

```bash
pytest
```

**Run specific test file:**

```bash
pytest tests/test_health.py
```

**Run specific test:**

```bash
pytest tests/test_health.py::TestHealthEndpoints::test_root_endpoint
```

**Run with verbose output:**

```bash
pytest -v
```

**Run with coverage:**

```bash
pytest --cov=app --cov-report=html
```

**Run only unit tests:**

```bash
pytest -m unit
```

---

## üö® Common CI/CD Issues

### Issue: "Tests pass locally but fail in CI"

**Solution:**

- CI uses fresh environment
- Check dependencies in requirements.txt
- Ensure tests are isolated (don't depend on external state)

### Issue: "Workflow takes too long"

**Solution:**

- Use caching for dependencies
- Run jobs in parallel
- Cache Docker layers

### Issue: "Deployment fails silently"

**Solution:**

- Add detailed logging
- Check status checks required
- Review deployment job logs

---

## ‚úÖ Verification Checklist

After completing Step 4:

- [ ] `.github/workflows/ci.yml` exists
- [ ] `.github/workflows/deploy.yml` exists
- [ ] Repository is on GitHub
- [ ] Workflows run on push (check Actions tab)
- [ ] All tests pass in CI
- [ ] Lint checks pass
- [ ] Docker image builds successfully
- [ ] Workflow logs are viewable
- [ ] Status badge works in README
- [ ] No sensitive data in workflow files

---

## üéì Key Concepts Learned

1. **Continuous Integration** - Automated testing on every commit
2. **Continuous Deployment** - Automated deployment on success
3. **GitHub Actions** - GitHub's CI/CD platform
4. **Workflows** - Automated processes
5. **Jobs** - Parallel tasks in workflow
6. **Caching** - Speed up by caching dependencies
7. **Secrets** - Secure sensitive data
8. **Status Checks** - Prevent merge of failing code
9. **Docker Registry** - Store and distribute images
10. **Monitoring** - Track workflow execution

---

## üîó Next Steps

Once CI/CD is set up, proceed to **Step 5: FastAPI Implementation**.

In Step 5, you will:

- Implement the complete search endpoint
- Integrate with SearXNG
- Add AI reasoning with DSPy
- Create proper request/response handling
- Add error handling and validation
- Implement logging and monitoring

---

## üí° Advanced Topics (Optional)

### Matrix Builds

Test against multiple Python versions:

```yaml
strategy:
  matrix:
    python-version: ['3.10', '3.11', '3.12']

- name: Setup Python
  uses: actions/setup-python@v4
  with:
    python-version: ${{ matrix.python-version }}
```

### Conditional Steps

```yaml
- name: Deploy only on main
  if: github.ref == 'refs/heads/main'
  run: ./deploy.sh
```

### Artifacts

```yaml
- name: Upload test results
  uses: actions/upload-artifact@v3
  with:
    name: test-results
    path: test-results/
```

---
