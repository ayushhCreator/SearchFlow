# Step 2: Dependency Management with uv

**Objective:** Set up the Python environment using `uv` package manager and install all project dependencies.

This step will guide you through using `uv` for fast, reliable dependency management, creating a virtual environment, and locking dependencies for reproducibility.

---

## ðŸŽ¯ What You Will Learn

- What is `uv` and why it's better than pip
- How to install `uv`
- How to create and activate a virtual environment
- How to manage dependencies with pyproject.toml
- How to lock dependencies for reproducibility
- How to install and verify dependencies

---

## ðŸ“š Background: What is uv?

### Traditional Approach (pip)

```
pip install package  â†’ Downloads from PyPI  â†’ Installs â†’ Possible conflicts
```

### uv Approach

```
uv add package  â†’ Resolves all dependencies  â†’ Locks versions  â†’ Fast & reliable
```

**Key Benefits of uv:**

- âš¡ **10-100x faster** than pip
- ðŸ”’ **Deterministic** - Always installs the same versions
- ðŸ“¦ **Handles lock files** automatically
- ðŸ **Python version management** built-in
- ðŸ”„ **Reproducible** builds across machines

---

## ðŸ› ï¸ Step-by-Step Setup

### Step 2.1: Install uv

**On Linux/macOS:**

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**On Windows (PowerShell):**

```powershell
powershell -ExecutionPolicy BypassUser -c "irm https://astral.sh/uv/install.ps1 | iex"
```

**Verify installation:**

```bash
uv --version
```

Expected output: `uv 0.x.x` (version number)

---

### Step 2.2: Create Virtual Environment

The virtual environment isolates project dependencies from your system Python.

**Create venv:**

```bash
uv venv .venv
```

This creates a `.venv` directory containing Python and pip.

**Activate virtual environment:**

On Linux/macOS:

```bash
source .venv/bin/activate
```

On Windows (Command Prompt):

```cmd
.venv\Scripts\activate.bat
```

On Windows (PowerShell):

```powershell
.venv\Scripts\Activate.ps1
```

**Verify activation:**

```bash
which python    # Linux/macOS
where python    # Windows
```

You should see the path includes `.venv`.

---

### Step 2.3: Update pyproject.toml

Your `pyproject.toml` already has basic structure. Let's enhance it with all SearchFlow dependencies:

```toml
[project]
name = "searchflow"
version = "0.1.0"
description = "Self-hosted AI-powered search backend that returns structured knowledge"
readme = "README.md"
requires-python = ">=3.12"
authors = [
    { name = "Ayush Raj", email = "ayush@example.com" },
]
license = { text = "MIT" }

dependencies = [
    # FastAPI & Web
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic>=2.0.0",
    "pydantic-settings>=2.0.0",

    # HTTP Client
    "httpx>=0.25.0",
    "aiohttp>=3.9.0",

    # Search & AI (to be added)
    # "dspy-ai>=2.0.0",
    # "searxng>=0.19.0",

    # Database (optional)
    # "sqlalchemy>=2.0.0",
    # "alembic>=1.12.0",

    # Logging & Monitoring
    "python-json-logger>=2.0.7",

    # Environment
    "python-dotenv>=1.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.1.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
    "mypy>=1.7.0",
]

test = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.1.0",
    "httpx>=0.25.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
python_files = "test_*.py"
python_classes = "Test*"
python_functions = "test_*"
addopts = "--strict-markers"
markers = [
    "unit: Unit tests",
    "integration: Integration tests",
    "slow: Slow tests",
]

[tool.black]
line-length = 100
target-version = ['py312']

[tool.ruff]
line-length = 100
target-version = "py312"

[tool.mypy]
python_version = "3.12"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false
```

**Why:** This structure allows:

- Core dependencies for all users
- Optional dev dependencies for developers
- Optional test dependencies for CI/CD
- Configuration for code quality tools

---

### Step 2.4: Install Dependencies

**Install with uv (recommended):**

```bash
uv pip install -e .
```

This command:

- `-e` = Editable mode (changes reflect immediately)
- `.` = Current directory (installs from pyproject.toml)
- Creates a `uv.lock` file automatically

**Alternative: Install specific dependency groups:**

```bash
# Install with dev dependencies
uv pip install -e ".[dev]"

# Install with test dependencies
uv pip install -e ".[test]"

# Install with everything
uv pip install -e ".[dev,test]"
```

---

### Step 2.5: Verify Installation

**Check all packages are installed:**

```bash
pip list
```

Should show FastAPI, uvicorn, pydantic, pytest, etc.

**Check Python version:**

```bash
python --version
```

Should be Python 3.12 or higher.

**Test import:**

```bash
python -c "import fastapi; print(fastapi.__version__)"
```

Should print the FastAPI version without errors.

---

### Step 2.6: Understanding uv.lock

After running `uv pip install`, a `uv.lock` file is created. This is crucial:

**What is uv.lock?**

- Records exact version of every package installed
- Ensures reproducible builds
- Used by CI/CD pipelines
- Should be committed to git

**Example uv.lock structure:**

```
[[package]]
name = "fastapi"
version = "0.104.0"
description = "FastAPI framework for building APIs with Python 3.6+"
requires-python = ">=3.7"
files = [
    {file = "fastapi-0.104.0-py3-none-any.whl", hash = "sha256:abc..."},
]

[[package]]
name = "pydantic"
version = "2.5.0"
description = "Data validation using Python type annotations"
requires-python = ">=3.7"
files = [
    {file = "pydantic-2.5.0-py3-none-any.whl", hash = "sha256:def..."},
]
```

**Why Lock Files Matter:**

- Production predictability: Exact same versions deploy everywhere
- Debugging: Easy to track which version caused an issue
- Security: Pin known safe versions, avoid auto-upgrades

---

### Step 2.7: Adding New Dependencies

**Add a package:**

```bash
uv pip install new-package
```

**Add multiple packages:**

```bash
uv pip install package1 package2 package3
```

**Add with version constraint:**

```bash
uv pip install "package>=1.0.0,<2.0.0"
```

**Update pyproject.toml:**
After adding packages with uv, update `dependencies` in pyproject.toml manually to track them.

---

### Step 2.8: Dependency Management Workflow

Here's the typical workflow:

```bash
# 1. Create/activate environment
uv venv .venv
source .venv/bin/activate

# 2. Install project with dev dependencies
uv pip install -e ".[dev,test]"

# 3. Add new dependency
uv pip install new-package

# 4. Update pyproject.toml dependencies list
# (Edit the file manually)

# 5. Commit lock file
git add uv.lock pyproject.toml
git commit -m "Add new-package dependency"
```

---

## ðŸ§ª Testing the Setup

Create a test script `test_setup.py`:

```python
"""
Test script to verify all dependencies are installed correctly.
"""

print("Testing SearchFlow dependencies...")

# Test FastAPI
try:
    import fastapi
    print(f"âœ… FastAPI {fastapi.__version__}")
except ImportError as e:
    print(f"âŒ FastAPI: {e}")

# Test Uvicorn
try:
    import uvicorn
    print(f"âœ… Uvicorn {uvicorn.__version__}")
except ImportError as e:
    print(f"âŒ Uvicorn: {e}")

# Test Pydantic
try:
    import pydantic
    print(f"âœ… Pydantic {pydantic.__version__}")
except ImportError as e:
    print(f"âŒ Pydantic: {e}")

# Test HTTPx
try:
    import httpx
    print(f"âœ… HTTPx {httpx.__version__}")
except ImportError as e:
    print(f"âŒ HTTPx: {e}")

# Test Pytest
try:
    import pytest
    print(f"âœ… Pytest {pytest.__version__}")
except ImportError as e:
    print(f"âŒ Pytest: {e}")

print("\nâœ¨ All dependencies verified!")
```

**Run test:**

```bash
python test_setup.py
```

Expected output:

```
Testing SearchFlow dependencies...
âœ… FastAPI 0.104.0
âœ… Uvicorn 0.24.0
âœ… Pydantic 2.5.0
âœ… HTTPx 0.25.0
âœ… Pytest 7.4.0

âœ¨ All dependencies verified!
```

---

## ðŸ“‹ Dependency Breakdown

Here's what each core dependency does:

| Package            | Purpose         | Why We Use It                         |
| ------------------ | --------------- | ------------------------------------- |
| **FastAPI**        | Web framework   | Modern, fast, automatic API docs      |
| **Uvicorn**        | ASGI server     | Runs FastAPI, supports async          |
| **Pydantic**       | Data validation | Schema validation, JSON serialization |
| **HTTPx**          | HTTP client     | Async HTTP requests for search        |
| **Pytest**         | Testing         | Industry-standard Python testing      |
| **pytest-asyncio** | Async testing   | Test async functions                  |
| **python-dotenv**  | Environment     | Load .env files for config            |

---

## ðŸš¨ Common Issues & Solutions

### Issue: "uv command not found"

**Solution:**

```bash
# Install uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# Add to PATH
export PATH="$HOME/.local/bin:$PATH"
```

### Issue: "ModuleNotFoundError" when running code

**Solution:**

```bash
# Verify venv is activated (should show .venv in prompt)
source .venv/bin/activate

# Reinstall
uv pip install -e ".[dev,test]"
```

### Issue: "pip is not installed"

**Solution:**

```bash
# Create fresh venv with pip
uv venv .venv --python-preference=only-managed
source .venv/bin/activate
```

### Issue: Python version conflict

**Solution:**

```bash
# Check system Python
python --version

# Create venv with specific Python
uv venv .venv --python 3.12
```

---

## âœ… Verification Checklist

After completing Step 2:

- [ ] `uv --version` works
- [ ] `.venv` directory exists
- [ ] Virtual environment activates successfully
- [ ] `pip list` shows all dependencies
- [ ] `python test_setup.py` passes all checks
- [ ] `uv.lock` file exists in project root
- [ ] `pyproject.toml` has all dependencies listed
- [ ] Can import FastAPI: `python -c "import fastapi"`
- [ ] Can run pytest: `pytest --version`

---

## ðŸŽ“ Key Concepts Learned

1. **Virtual Environments** - Isolated Python environments for projects
2. **Dependency Management** - Managing package versions reliably
3. **Lock Files** - Ensuring reproducible builds
4. **Optional Dependencies** - Different packages for dev/test/prod
5. **Package Managers** - Why uv is better than pip
6. **Import Testing** - Verifying packages are installed correctly

---

## ðŸ”— Next Steps

Once dependencies are installed, proceed to **Step 3: Docker Setup**.

In Step 3, you will:

- Understand Docker containers and images
- Build Docker images for the API and SearXNG
- Set up Docker Compose for multi-service orchestration
- Run services locally in containers

---

## ðŸ’¡ Advanced Topics (Optional)

### Pinning Specific Versions

```toml
dependencies = [
    "fastapi==0.104.0",  # Exact version
    "uvicorn>=0.24.0,<0.25.0",  # Range
]
```

### Using Constraints Files

```bash
# Create constraints file
pip freeze > constraints.txt

# Install with constraints
uv pip install -c constraints.txt
```

### Viewing Dependency Tree

```bash
pip list --format freeze
# or
pipdeptree
```

---
