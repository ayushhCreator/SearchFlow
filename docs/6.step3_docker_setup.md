# Step 3: Docker Setup and Configuration

**Objective:** Set up Docker containerization for the SearchFlow application and understand how to build and run containers.

This step will guide you through Docker concepts, creating Dockerfiles, building images, and using Docker Compose to orchestrate multiple services.

---

## üéØ What You Will Learn

- What Docker is and why containerization matters
- How to write Dockerfiles
- How to build Docker images
- How to run containers locally
- How to use Docker Compose for multi-service setup
- Difference between images and containers
- Best practices for containerization

---

## üê≥ Background: Understanding Docker

### Without Docker

```
Development ‚Üí pip install ‚Üí venv setup ‚Üí Works on my machine
             ‚Üí Deployment ‚Üí "It works on my machine!" problem
```

### With Docker

```
Code + Dockerfile ‚Üí Build Image ‚Üí Run Container ‚Üí Same everywhere
```

**Key Concepts:**

| Concept            | Explanation                                                      |
| ------------------ | ---------------------------------------------------------------- |
| **Image**          | Snapshot of application with all dependencies (like a blueprint) |
| **Container**      | Running instance of an image (like a running program)            |
| **Dockerfile**     | Recipe for building an image                                     |
| **Docker Compose** | Tool to run multiple containers together                         |
| **Volume**         | Persistent storage for containers                                |
| **Port Mapping**   | Mapping container ports to host machine ports                    |

---

## üõ†Ô∏è Step-by-Step Setup

### Step 3.1: Install Docker

**On Linux:**

```bash
# Update package manager
sudo apt-get update

# Install Docker
sudo apt-get install -y docker.io docker-compose

# Add user to docker group (avoid sudo)
sudo usermod -aG docker $USER
newgrp docker

# Verify installation
docker --version
docker compose --version
```

**On macOS (Homebrew):**

```bash
brew install docker docker-compose

# Start Docker Desktop (GUI app)
open /Applications/Docker.app

# Verify
docker --version
```

**On Windows (Docker Desktop):**

- Download from https://www.docker.com/products/docker-desktop
- Install and run Docker Desktop
- Verify in PowerShell: `docker --version`

---

### Step 3.2: Understand the Dockerfile

**Location:** `docker/Dockerfile.api`

Let's break down each line:

```dockerfile
# Use official Python image as base
FROM python:3.12-slim

# Set working directory inside container
WORKDIR /app

# Install system-level dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements file to container
COPY requirements.txt .

# Install Python packages
RUN pip install --no-cache-dir -r requirements.txt

# Copy entire application to container
COPY . .

# Expose port for API
EXPOSE 8007

# Command to run when container starts
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8007"]
```

**What happens when you build this:**

1. Downloads Python 3.12 slim image (~200MB)
2. Creates `/app` directory inside container
3. Installs gcc (needed for some packages)
4. Copies and installs Python dependencies
5. Copies your application code
6. Exposes port 8007
7. Sets up the startup command

**Why slim image?**

- Full Python image: ~900MB
- Slim Python image: ~200MB
- Saves space, faster deployment

---

### Step 3.3: Update requirements.txt

First, update `requirements.txt` from your virtual environment:

```bash
# Activate virtual environment (if not already)
source .venv/bin/activate

# Generate requirements.txt
pip freeze > requirements.txt
```

**Check contents:**

```bash
cat requirements.txt
```

Should show:

```
fastapi==0.104.0
uvicorn==0.24.0
pydantic==2.5.0
httpx==0.25.0
pytest==7.4.0
...
```

**Why both pyproject.toml and requirements.txt?**

- `pyproject.toml`: Source of truth for development
- `requirements.txt`: Exact versions for production/Docker
- Docker uses `requirements.txt` for reproducible builds

---

### Step 3.4: Create Improved Dockerfile

Update `docker/Dockerfile.api` with best practices:

```dockerfile
# Multi-stage build - reduces final image size
FROM python:3.12-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .

# Create wheels for all packages (faster installation in final stage)
RUN pip install --no-cache-dir --user --no-warn-script-location \
    -r requirements.txt

# Final stage - smaller image
FROM python:3.12-slim

WORKDIR /app

# Copy Python packages from builder
COPY --from=builder /root/.local /root/.local

# Update PATH
ENV PATH=/root/.local/bin:$PATH

# Copy application
COPY . .

# Create non-root user for security
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app

USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8007/health')"

# Expose port
EXPOSE 8007

# Run application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8007"]
```

**Improvements:**

- **Multi-stage build**: Final image ~400MB instead of ~1GB
- **Non-root user**: Security best practice
- **Health check**: Docker monitors if service is healthy
- **Caching optimization**: Layers are cached between builds

---

### Step 3.5: Build Docker Image

**Build the image:**

```bash
docker build -f docker/Dockerfile.api -t searchflow:latest .
```

Breakdown:

- `-f docker/Dockerfile.api`: Use this Dockerfile
- `-t searchflow:latest`: Tag the image as "searchflow" with version "latest"
- `.`: Build context (current directory)

**Verify build:**

```bash
docker images | grep searchflow
```

Should show:

```
REPOSITORY   TAG      IMAGE ID       CREATED         SIZE
searchflow   latest   abc123def456   2 minutes ago    400MB
```

**What happens during build:**

```
Step 1/11 : FROM python:3.12-slim
Step 2/11 : WORKDIR /app
Step 3/11 : RUN apt-get update && apt-get install -y --no-install-recommends gcc
...
Successfully built abc123def456
Successfully tagged searchflow:latest
```

---

### Step 3.6: Run Container Locally

**Run the container:**

```bash
docker run -p 8007:8007 searchflow:latest
```

Breakdown:

- `-p 8007:8007`: Map port 8007 (host) to 8007 (container)
- `searchflow:latest`: Image to run

**Test the API:**

```bash
# In another terminal
curl http://localhost:8007/

# Expected response
{"message":"SearchFlow is running"}
```

**Stop container:**

```bash
# Find running containers
docker ps

# Stop by container ID
docker stop container_id

# Or press Ctrl+C in the original terminal
```

---

### Step 3.7: Create Docker Compose File

Update `docker-compose.yml` for multi-service setup:

```yaml
version: "3.8"

services:
  # FastAPI Application
  api:
    build:
      context: .
      dockerfile: docker/Dockerfile.api
    container_name: searchflow-api
    ports:
      - "8007:8007"
    environment:
      - DEBUG=false
      - LOG_LEVEL=INFO
      - SEARXNG_URL=http://searxng:8888
    depends_on:
      - searxng
    volumes:
      - .:/app # Hot reload for development
      - /app/__pycache__ # Don't sync pycache
    command: uvicorn app.main:app --host 0.0.0.0 --port 8007 --reload
    networks:
      - searchflow-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8007/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # SearXNG Search Engine
  searxng:
    image: searxng/searxng:latest
    container_name: searchflow-searxng
    ports:
      - "8888:8888"
    environment:
      - SEARXNG_SECRET=your-secret-key-here
      - BASE_URL=http://localhost:8888/
    volumes:
      - searxng-data:/data
      - ./docker/searxng-settings.yml:/etc/searxng/settings.yml:ro
    networks:
      - searchflow-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8888/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  searxng-data:

networks:
  searchflow-network:
    driver: bridge
```

**What this does:**

- Defines two services: API and SearXNG
- API depends on SearXNG (waits for it to start)
- Maps ports so you can access them locally
- Shares a network so containers can communicate
- Uses volumes for data persistence and code reloading
- Includes health checks for reliability

---

### Step 3.8: Run with Docker Compose

**Start all services:**

```bash
docker-compose up
```

Output should show:

```
Creating searchflow-searxng ... done
Creating searchflow-api ... done
Attaching to searchflow-searxng, searchflow-api
api_1      | INFO:     Uvicorn running on http://0.0.0.0:8007
```

**Run in background:**

```bash
docker-compose up -d
```

The `-d` flag runs in detached mode (background).

**View logs:**

```bash
docker-compose logs -f api
```

**Stop services:**

```bash
docker-compose down
```

---

### Step 3.9: Test the Setup

**Check services are running:**

```bash
docker-compose ps
```

Should show both `api` and `searxng` as "Up".

**Test API health:**

```bash
curl http://localhost:8007/health
```

Expected response:

```json
{ "status": "healthy", "version": "0.1.0", "service": "SearchFlow API" }
```

**Test SearXNG:**

```bash
curl http://localhost:8888/
```

Should return HTML (SearXNG web interface).

**View container logs:**

```bash
docker-compose logs api
docker-compose logs searxng
```

---

### Step 3.10: Common Docker Commands

**Build commands:**

```bash
# Build image with tag
docker build -t myimage:1.0 .

# Build without cache (forces rebuild)
docker build --no-cache -t myimage:1.0 .

# Build multiple images
docker-compose build
```

**Run commands:**

```bash
# Run container
docker run -p 8007:8007 myimage

# Run in background
docker run -d -p 8007:8007 myimage

# Run with environment variables
docker run -e DEBUG=true -p 8007:8007 myimage

# Run with volume
docker run -v $(pwd):/app -p 8007:8007 myimage
```

**Management commands:**

```bash
# List images
docker images

# List running containers
docker ps

# List all containers
docker ps -a

# Remove image
docker rmi myimage:1.0

# Remove container
docker rm container_id

# View container logs
docker logs container_id

# Execute command in running container
docker exec -it container_id bash

# Get container info
docker inspect container_id
```

---

## üìÅ Docker Ignore File

Create `docker/.dockerignore` to exclude unnecessary files:

```
__pycache__
*.pyc
.pytest_cache
.venv
venv
.env
.env.local
.git
.gitignore
.DS_Store
*.md
htmlcov
.mypy_cache
.coverage
uv.lock
```

This speeds up builds by not copying unnecessary files into the image.

---

## üß™ Testing Docker Setup

Create a test script `test_docker.sh`:

```bash
#!/bin/bash

echo "Testing Docker setup..."

# Check Docker is installed
if ! command -v docker &> /dev/null; then
    echo "‚ùå Docker not installed"
    exit 1
fi
echo "‚úÖ Docker installed"

# Check Docker Compose
if ! command -v docker-compose &> /dev/null; then
    echo "‚ùå Docker Compose not installed"
    exit 1
fi
echo "‚úÖ Docker Compose installed"

# Start services
echo "Starting services..."
docker-compose up -d

# Wait for services
sleep 10

# Test API health
echo "Testing API health..."
if curl -f http://localhost:8007/health > /dev/null 2>&1; then
    echo "‚úÖ API is healthy"
else
    echo "‚ùå API health check failed"
    docker-compose logs api
    exit 1
fi

# Test SearXNG
echo "Testing SearXNG..."
if curl -f http://localhost:8888/ > /dev/null 2>&1; then
    echo "‚úÖ SearXNG is running"
else
    echo "‚ùå SearXNG failed"
    docker-compose logs searxng
    exit 1
fi

echo "‚ú® All Docker tests passed!"

# Cleanup
docker-compose down
```

**Run test:**

```bash
bash test_docker.sh
```

---

## üö® Common Issues & Solutions

### Issue: "Cannot connect to Docker daemon"

**Solution:**

```bash
# On Linux, start Docker
sudo systemctl start docker

# On macOS, open Docker Desktop
open /Applications/Docker.app
```

### Issue: "Port 8007 already in use"

**Solution:**

```bash
# Find what's using port 8007
lsof -i :8007

# Use different port
docker run -p 8001:8007 searchflow:latest
```

### Issue: "Image build fails - permission denied"

**Solution:**

```bash
# On Linux, add user to docker group
sudo usermod -aG docker $USER
newgrp docker

# Logout and login again
```

### Issue: "Dockerfile not found"

**Solution:**

```bash
# Make sure you're in project root
pwd

# Check file exists
ls -la docker/Dockerfile.api

# Build with correct path
docker build -f docker/Dockerfile.api -t searchflow:latest .
```

---

## ‚úÖ Verification Checklist

After completing Step 3:

- [ ] Docker is installed (`docker --version`)
- [ ] Docker Compose is installed (`docker-compose --version`)
- [ ] `docker/Dockerfile.api` exists and is readable
- [ ] `docker-compose.yml` is properly formatted
- [ ] `requirements.txt` is up to date
- [ ] Docker image builds successfully
- [ ] Container runs and exposes port 8007
- [ ] API health check passes
- [ ] Both services start with `docker-compose up`
- [ ] Services stop cleanly with `docker-compose down`

---

## üéì Key Concepts Learned

1. **Containerization** - Packaging applications with all dependencies
2. **Docker Images** - Blueprints for containers
3. **Docker Containers** - Running instances of images
4. **Dockerfiles** - Instructions to build images
5. **Multi-stage Builds** - Creating smaller, optimized images
6. **Docker Compose** - Orchestrating multiple services
7. **Volume Mounting** - Sharing files between host and container
8. **Health Checks** - Monitoring container health
9. **Environment Variables** - Configuration in containers
10. **Networking** - Communication between containers

---

## üîó Next Steps

Once Docker is set up and working, proceed to **Step 4: CI/CD Basics**.

In Step 4, you will:

- Understand what CI/CD is and why it matters
- Create GitHub Actions workflows
- Set up automated testing
- Implement automated deployment
- Learn about GitHub runners and workflow syntax

---

## üí° Advanced Topics (Optional)

### Docker Registries

```bash
# Tag image for registry
docker tag searchflow:latest docker.io/username/searchflow:latest

# Push to Docker Hub
docker login
docker push username/searchflow:latest

# Pull from registry
docker pull username/searchflow:latest
```

### Docker Network Types

```bash
# Create custom network
docker network create searchflow-net

# Run containers on network
docker run --network searchflow-net -p 8007:8007 searchflow:latest
```

### Docker Volume Types

```bash
# Named volume (persistent)
docker volume create searchflow-data
docker run -v searchflow-data:/data searchflow:latest

# Bind mount (directory mapping)
docker run -v $(pwd):/app searchflow:latest

# Temporary volume
docker run -v /tmp:/tmp searchflow:latest
```

---
